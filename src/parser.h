//
// Created by tumbar on 12/22/20.
//

#ifndef NEOAST_PARSER_H
#define NEOAST_PARSER_H

#include <stdio.h>
#include "common.h"

typedef int (*parser_expr) (void* dest, void** values);

enum
{
    // A token generated by the lexer
    // Fills the original token table
    TOK_ACTION_MASK = 1 << 29,

    // A compound statement generated
    // by reducing a grammar rule
    TOK_VARIABLE_MASK = 1 << 30,

    // Points to a reduction that can be made
    // Passes the compound expression into a
    // parser grammar rule handler.
    TOK_REDUCE_MASK = 1 << 31,

    // Unexpected token or expression
    TOK_SYNTAX_ERROR = 0
};

struct GrammarParser_prv
{
    int lex_n;
    int grammar_n;
    LexerRule* lexer_rules;
    GrammarRule* grammar_rules;
};

struct GrammarRule_prv
{
    int* grammar;
    parser_expr expr;
};

struct ParserState_prv
{
    const char* buffer;
    void* lval;
};

/**
 * Use the lexer to get every token in a string
 * We will stop parsing on the first token that is
 * not handled by a lexer rule
 * @param input buffer to parse
 * @param parse grammar parser reference
 * @param table table of tokens that we parsed (null terminated)
 * @param val_table value table
 * @param val_n offset of a value (size of value union)
 * @return number of parsed tokens
 */
int parser_fill_table(const char** input, GrammarParser* parse, int* table, void* val_table, size_t val_n, int table_n);

/**
 * Try to reduce the token table using
 * the grammar rules stored in parser.
 * Keep reducing the table until no more operations
 * can be performed.
 *
 * @param parser reference with grammar rules
 * @param n number of tokens/values (subject to changes after return)
 * @param tokens token data
 * @param val_table table of parsed values
 * @param val_s size of each value in val_table
 * @return
 */
void parser_parse(GrammarParser* parser, int* n, int* tokens, void* val_table, size_t val_s);

#endif //NEOAST_PARSER_H
